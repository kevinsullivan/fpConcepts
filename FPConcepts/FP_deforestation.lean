/-!
Deforestation is a program transformation technique that eliminates intermediate data structures (e.g., trees, lists) generated by compositions of functions, by fusing producers and consumers into a single loop or recursive definition.

Key benefits:
1. **Performance**: Removes allocation and traversal of intermediate structures.
2. **Fusion**: Combines multiple passes into one, improving locality and cache usage.
3. **Composability**: Retains high-level functional composition without runtime overhead.
-/

namespace Deforestation

universe u

/-- A simple list producer: generates a list by applying `f` to numbers 0 through `n-1`. -/
partial def produceList {α : Type u} (n : Nat) (f : Nat → α) : List α :=
  if n == 0 then []
  else f 0 :: produceList (n - 1) (fun i => f (i + 1))

/-- A consumer: sums elements of a list. -/
def sumList (l : List Nat) : Nat :=
  l.foldl (· + ·) 0

-- Example without fusion: produce then consume
def exampleNaive (n : Nat) : Nat :=
  let xs := produceList n id
  sumList xs

/-- Deforested version combines producer and consumer: -/
partial def fusedSum (n : Nat) (f : Nat → Nat) : Nat :=
  if n == 0 then 0
  else f 0 + fusedSum (n - 1) (fun i => f (i + 1))

-- Example with fusion: no intermediate list allocation
def exampleFused (n : Nat) : Nat :=
  fusedSum n id

/-! ### Examples -/

#eval exampleNaive 5    -- produces [0,1,2,3,4] then sums = 10
#eval exampleFused 5   -- directly computes sum = 10

/-- Another scenario: map then sum -/
def exampleMapSumNaive (n : Nat) : Nat :=
  let xs := produceList n (fun i => i * 2)
  sumList xs

def exampleMapSumFused (n : Nat) : Nat :=
  fusedSum n fun i => i * 2

#eval exampleMapSumNaive 5  -- sum of [0,2,4,6,8] = 20
#eval exampleMapSumFused 5  -- fused = 20

end Deforestation
